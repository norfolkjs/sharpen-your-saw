<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Sharpen Your Saw 4</title>

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h2>Sharpen Your Saw (5)</h2>
          <ol>
            <li class="fragment">The Presentation</li>
            <li class="fragment">The Challenge</li>
            <li class="fragment">Show and Tell</li>
          </ol>
        </section>

				<section>
					<h3>Redux</h3>
          <div class="fragment">Library for managing application state</div>
          <div class="fragment">Commonly paired with React</div>
          <!-- poll audience -->
        </section>

				<section>
  				<section>
  					<h3>Beginning of the slides about React</h3>
            <div class="fragment">Initial renders are easy. Mutating UI is hard.</div>
            <div class="fragment">Pure functions are good. Side effects are bad.</div>
					</section>

          <section>
  					<h3>Write as if UI were a pure function of state</h3>
            <div class="fragment">Lots of mutative magic under the hood</div>
  				</section>
        </section>
				<section>
  				<section>
  					<h3>Application state</h3>
            <div class="fragment">What if you could manage it with pure functions?</div>
            <div class="fragment">
    					<pre><code class="hljs">
(oldState, action) => newState
              </code></pre>
            </div>
            <div class="fragment">
    					<pre><code class="hljs">
function updateState (oldState, action) {
  return someTransformation(oldState, action.releventPayload);
}
              </code></pre>
            </div>
            <div class="fragment">
    					<pre><code class="hljs">
function incrementState (oldState, action) {
  return _.assign({}, state, {
    counter: state.counter + action.incrementBy
  });
}
              </code></pre>
            </div>
					</section>
  				<section>
  					<h3>Before</h3>
  					<pre><code class="hljs">
handleChange(event) {
  this.setState({ fieldValue: event.target.value });
}
            </code></pre>
  					<h3>After</h3>
  					<pre><code class="hljs">
handleChange(event) {
  this.props.dispatch({
    type: "SET_FIELD_VALUE",
    value: event.target.value
  });
}
            </code></pre>
  					<pre><code class="hljs">
function fieldValueReducer(state, action) {
  return _.assign({}, state, { fieldValue: action.value });
}
            </code></pre>
					</section>
        </section>

				<section>
  				<section>
  					<h3>Two Gripes</h3>
            <div class="fragment">1. Too much boilerplate</div>
            <div class="fragment">2. Writing immutable code can be painful</div>
          </section>

          <section>
            <h3>Mutable code</h3>
            <pre><code class="hljs">
const oldState = { size: 2 };
const newState = oldState;
newState.size = 4;
oldState === newState
// true
            </code></pre>
          </section>

          <section>
            <h3>Immutable code</h3>
            <pre><code class="hljs">
const oldState = { size: 2 };
const newState = _.assign({}, oldState, { size: 4 });
oldState === newState
// false
            </code></pre>
          </section>

          <section>
            <h3>Immutable code in Redux</h3>
            <pre><code class="hljs">
function updateSize(state, action) {
  return _.assign({}, state, { size: action.size });
}
            </code></pre>
          </section>

          <section>
            <h3>Immutable code in Redux</h3>
            <pre><code class="hljs">
function updateSizeOfItemInArray(state, action) {
  return _.assign({}, state, {
    itemList: [
      ...state.itemList.slice(0, action.index),
      _.assign({}, state.itemList[action.index], {
        size: action.size
      }),
      ...state.itemList.slice(action.index + 1)
    ]
  });
}
            </code></pre>
          </section>

          <section>
            <h3>Immutable code in Redux</h3>
            <pre><code class="hljs">
function updateSizeOfItemInArray(state, action) {
  const newState = _.cloneDeep(state);
  newState[action.index].size = action.size;
  return newState;
}
            </code></pre>
          </section>
        </section>
      </section>
      <section>
        <section>
					<h3>Part 2: The Challenge</h3>
        https://shackbarth.github.io/sharpen-your-saw-4
        </section>
      </section>
      <section>
          <section>
  					<h3>Part 3: Show and Tell</h3>
  				</section>
          <section>
  					<h3>Joseph Pickard</h3>
  					<pre><code class="hljs">
const fs = require('mz/fs');

function fixCsv(dir) {
  return fs.readdir(dir).then(files => Promise.all(files.map(file => {
    if (/\.csv$/.exec(file)) {
      return fs.rename(dir + '/' + file, dir + '/' + file.replace(/\.csv$/, '.txt'));
    }
  })));
}

module.exports = fixCsv;
            </code></pre>
  				</section>
          <section>
  					<h3>Travis Webb</h3>
  					<pre><code class="hljs">
const dir = '.' // set dir
const co = require('co')
const fs = require('mz/fs')

co(function *() {
  const files = yield fs.readdir(dir)
  for (const f of files) {
   if (/\.csv$/.test(f)) {
     yield fs.rename(f, f.replace(/\.csv$/, '.txt'))
  }
})
            </code></pre>
  				</section>


          <section>
  					<h3>Joseph Pickard</h3>
  					<pre><code class="hljs">
const fs = require('mz/fs');

function fixCsv(dir) {
    return fs.readdir(dir).then(files => Promise.all(files.map(file => {
        let fileFull = dir + '/' + file;
        fs.stat(fileFull).then(s => {
            if (s.isDirectory()) {
                return fixCsv(fileFull);
            } else if (/\.csv$/.exec(file)) {
                return fs.rename(dir + '/' + file, dir + '/' + file.replace(/\.csv$/, '.txt'));
            }
        });
    })));
}

module.exports = fixCsv;

            </code></pre>
  				</section>




          <section>
  					<h3></h3>
  					<pre><code class="hljs">
const fs = require('mz/fs')
  const path = require('path')

  function fixStuff (dir, fullpath = __dirname) {
    return co(function *() {
      const files = yield fs.readdir(path.resolve(fullpath, dir))

      for (const f of files) {
        if (yield fs.stat(f).isDirectory()) {
          return fixStuff(f, fullpath)
        }
        else {
          if (/\.csv$/.test(f)) {
            yield fs.rename(f, f.replace(/\.csv$/, '.txt'))
          }
        }
      }
    })
}
            </code></pre>
  				</section>

          <section>
  					<h3>Stanley Zheng</h3>
  					<pre><code class="hljs">
              const co = require('co');
var fs = require('mz/fs')
var test_dir = "test_dir";

// The challenge
// You walk into work, csv is bullshit
// Takes a directory and it fixes all the csv files in the directory, changes to to txt
// Extra bonus if it recurses
(function () {
    console.log('hello world!')

    co(main).then(function (f) {
        console.log('foo')
        f.forEach(fn => {
            const newname = fn.replace('.csv', '.txt')
            fs.renameSync('${test_dir}/{fn}', '${test_dir}/{newname}');
        })
    }, function (err) {
        console.error(err.stack);
    })
}())

function* main() {
    var result = yield fs.readdir(test_dir)

    return result.filter(a => {
        return a.includes('.csv')
    });
}


function* rename() {
    console.log("foo")
}

            </code></pre>
  				</section>

          <section>
  					<h3>Steve Nelson</h3>
  					<pre><code class="hljs">
  var fs = require('fs');

  if (process.argv.length <= 2) {
      console.log("Usage: " + __filename + " path/to/directory");
      process.exit(-1);
  }

  var path = process.argv[2];
  var fs = require('fs');
  var newresults = [];
  var walk = function(dir, done) {

    var results = [];
    fs.readdir(dir, function(err, list) {
      if (err) return done(err);
      var i = 0;
      (function next() {
        var file = list[i++];
        if (!file) return done(null, results);

        var change=false;
        if(file.split(".")[1]=='csv'){
        change=true;
        }

        file = dir + '/' + file;
        if (change){
        fs.rename(file, file.split(".")[0]+".txt", function (err) {
    if (err) throw err;
    console.log('renamed complete');
  });
}
        fs.stat(file, function(err, stat) {
          if (stat && stat.isDirectory()) {
            walk(file, function(err, res) {
              results = results.concat(res);
              next();
            });
          } else {
            results.push(file);
            next();
          }
        });
      })();
    });
  };
  console.log(path);

  walk(path, function(err, results) {
    if (err) throw err;
    console.log(results);
  });

  //server.listen(8000);
  //console.log("loaded!");
            </code></pre>
  				</section>

          <section>
  					<h3>Steve Hackbarth</h3>
  					<pre><code class="hljs">
const co = require("co");
const { readdir, rename, stat } = require("mz/fs");
const path = require("path");

function unCsv (dirname) {
  co(function *() {
    const files = yield readdir(dirname);
    for (file of files) {
      if (path.extname(file) === ".csv") {
        const oldName = path.resolve(dirname, file);
        const newName = oldName.substring(0, oldName.length - 3) + "txt";
        yield rename(oldName, newName);
      }
    }
    console.log("success!");
  }).catch((error) => {
    console.error(error);
  });
}

unCsv(path.resolve(__dirname, "my_dir"));
            </code></pre>
  				</section>
          <section>
  					<h3>Steve Hackbarth</h3>
  					<pre><code class="hljs">
const co = require("co");
const { readdir, rename, stat } = require("mz/fs");
const path = require("path");

function unCsvRecursive (dirname) {
  return new Promise((resolve, reject) => {
    co(function *() {
      const files = yield readdir(dirname);
      for (file of files) {
        const fullName = path.resolve(dirname, file);
        const stats = yield stat(fullName);
        if (stats.isDirectory()) {
          yield unCsvRecursive(fullName);
        } else if (path.extname(file) === ".csv") {
          const newName = fullName.substring(0, fullName.length - 3) + "txt";
          yield rename(fullName, newName);
        }
      }
      resolve();
    }).catch(reject);
  });
}

unCsvRecursive(path.resolve(__dirname, "my_dir")).then(console.log, console.error);

            </code></pre>
  				</section>
        </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>
	</body>
</html>
